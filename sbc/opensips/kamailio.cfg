#!KAMAILIO
#
# Minimal Kamailio config: SBC for NAT traversal
# Rewrites bad SDP (c=IN IP4 127.0.0.1) to use actual source IP
#

####### Global Parameters #######

debug=2
log_stderror=yes
fork=yes
children=4

listen=udp:0.0.0.0:5060
port=5060

####### Modules Section #######

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "usrloc.so"
loadmodule "nathelper.so"
loadmodule "sdpops.so"
loadmodule "htable.so"

# ----- htable for storing NAT mappings -----
modparam("htable", "htable", "natmap=>size=8;autoexpire=3600;")

# ----- tm params -----
modparam("tm", "fr_timer", 5000)
modparam("tm", "fr_inv_timer", 30000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 0)
modparam("nathelper", "received_avp", "$avp(received)")

####### Routing Logic #######

request_route {
    # MAX-FORWARDS check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # record routing for dialog forming requests
    # Use add_rr_param to store the source IP:port for NAT traversal
    if (is_method("INVITE|SUBSCRIBE")) {
        # Add received param to record-route so we can route back to NATed client
        record_route_preset("kamailio:5060;nat=yes");
        # Store caller's NAT address keyed by Call-ID
        $sht(natmap=>$ci) = $si + ":" + $sp;
        xlog("L_INFO", "Stored NAT mapping: $ci -> $si:$sp\n");
    }

    # handle requests within established dialogs (BYE, ACK, re-INVITE, etc.)
    if (has_totag()) {
        xlog("L_INFO", "In-dialog request: $rm from $si:$sp to $ru (Call-ID: $ci)\n");
        if (loose_route()) {
            # For BYE from Asterisk to Zoiper, we need to send to Zoiper's NAT address
            # Check if we have a stored NAT mapping for this Call-ID
            if ($sht(natmap=>$ci) != $null) {
                xlog("L_INFO", "Found NAT mapping: $sht(natmap=>$ci)\n");
                # If request is going to a private IP, rewrite destination
                if ($rd =~ "^192\.168\.|^10\.|^172\.(1[6-9]|2[0-9]|3[01])\.") {
                    xlog("L_INFO", "Rewriting dest from $rd to NAT address\n");
                    $du = "sip:" + $sht(natmap=>$ci);
                }
            }
            t_relay();
            exit;
        }
        xlog("L_WARN", "In-dialog request $rm without route header\n");
    }

    # NAT detection and handling
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        }
        setflag(5);
    }

    # REGISTER handling
    if (is_method("REGISTER")) {
        $du = "sip:asterisk:5060";
        t_relay();
        exit;
    }

    # INVITE processing - fix bad SDP
    if (is_method("INVITE")) {
        xlog("L_INFO", "Processing INVITE from $si:$sp\n");
        if (has_body("application/sdp")) {
            # Replace 127.0.0.1 in SDP with actual source IP
            xlog("L_INFO", "Rewriting SDP - replacing 127.0.0.1 with $si\n");
            subst_body("/c=IN IP4 127\.0\.0\.1/c=IN IP4 $si/g");
        }
        t_on_reply("MANAGE_REPLY");
    }

    # Forward to Asterisk
    $du = "sip:asterisk:5060";
    if (!t_relay()) {
        sl_reply_error();
    }
}

# Reply route - fix SDP in responses for NAT
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "Reply: $rs\n");
    if (has_body("application/sdp")) {
        xlog("L_INFO", "Reply has SDP body, attempting rewrite\n");
        # Replace Asterisk's internal Docker IP with host-accessible IP
        # Match any Docker network (172.x.x.x)
        if (subst_body("/c=IN IP4 172\.[0-9]+\.[0-9]+\.[0-9]+/c=IN IP4 10.44.88.37/g")) {
            xlog("L_INFO", "SDP rewritten successfully\n");
        } else {
            xlog("L_WARN", "SDP rewrite failed or no match\n");
        }
    }
    if (isflagset(5) && status=~"(18[0-9]|2[0-9][0-9])") {
        fix_nated_contact();
    }
}
