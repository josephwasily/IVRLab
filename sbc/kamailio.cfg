/* Minimal Kamailio config to proxy to Asterisk and use rtpengine to anchor media
   - Kamailio listens on UDP 5060 inside container; host maps to 5062 to avoid clashing
   - For incoming INVITEs, Kamailio will call rtpengine_offer() before forwarding to Asterisk
   - On 200 OK, it will call rtpengine_answer() to complete anchoring
   - This config is intentionally minimal and focuses on the SIP proxy + rtpengine flow
*/

#!define WITH_MYSQL 0
debug=3
log_stderror=1

# --- modules ---
loadmodule "proto_udp.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "rtpengine.so"

# --- rtpengine parameters ---
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:2223")

# --- global parameters ---
mpath="/usr/local/etc/kamailio"

route {
    # handle max-forwards and traditional pre-checks
    if (!mf_process_maxfwd_header()) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if (method=="REGISTER") {
        # forward registers to Asterisk (let Asterisk handle registrations)
        t_relay_to("sip:asterisk:5060");
        exit;
    }

    if (is_method("INVITE")) {
        if (has_body()) {
            xlog("L_INFO","INVITE has body; offering to rtpengine to anchor media\n");
            if (!rtpengine_offer("replace-origin replace-session-connection")) {
                xlog("L_ERR","rtpengine_offer failed\n");
            }
        }
        # proxy the INVITE to Asterisk
        t_relay_to("sip:asterisk:5060");
        exit;
    }

    # For other methods, just relay to Asterisk
    t_relay_to("sip:asterisk:5060");
}

onreply_route {
    # When 200 OK arrives for INVITE, call rtpengine_answer to finish anchoring
    if (is_method("INVITE") && status=~"2[0-9][0-9]") {
        if (has_body()) {
            if (!rtpengine_answer("replace-origin replace-session-connection")) {
                xlog("L_ERR","rtpengine_answer failed\n");
            }
        }
    }
    # forward replies back to caller
    t_relay();
}

request_route[RELAY] {
    t_relay();
}
